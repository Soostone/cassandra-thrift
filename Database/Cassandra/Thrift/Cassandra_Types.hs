{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift                                     --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Database.Cassandra.Thrift.Cassandra_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Int
import Data.Typeable ( Typeable )
import qualified Data.Map as Map
import qualified Data.Set as Set

import Thrift


data ConsistencyLevel = ONE|QUORUM|LOCAL_QUORUM|EACH_QUORUM|ALL|ANY|TWO|THREE  deriving (Show,Eq, Typeable, Ord)
instance Enum ConsistencyLevel where
  fromEnum t = case t of
    ONE -> 1
    QUORUM -> 2
    LOCAL_QUORUM -> 3
    EACH_QUORUM -> 4
    ALL -> 5
    ANY -> 6
    TWO -> 7
    THREE -> 8
  toEnum t = case t of
    1 -> ONE
    2 -> QUORUM
    3 -> LOCAL_QUORUM
    4 -> EACH_QUORUM
    5 -> ALL
    6 -> ANY
    7 -> TWO
    8 -> THREE
    _ -> throw ThriftException
data IndexOperator = EQ|GTE|GT|LTE|LT  deriving (Show,Eq, Typeable, Ord)
instance Enum IndexOperator where
  fromEnum t = case t of
    EQ -> 0
    GTE -> 1
    GT -> 2
    LTE -> 3
    LT -> 4
  toEnum t = case t of
    0 -> EQ
    1 -> GTE
    2 -> GT
    3 -> LTE
    4 -> LT
    _ -> throw ThriftException
data IndexType = KEYS  deriving (Show,Eq, Typeable, Ord)
instance Enum IndexType where
  fromEnum t = case t of
    KEYS -> 0
  toEnum t = case t of
    0 -> KEYS
    _ -> throw ThriftException
data Compression = GZIP|NONE  deriving (Show,Eq, Typeable, Ord)
instance Enum Compression where
  fromEnum t = case t of
    GZIP -> 1
    NONE -> 2
  toEnum t = case t of
    1 -> GZIP
    2 -> NONE
    _ -> throw ThriftException
data CqlResultType = ROWS|VOID|INT  deriving (Show,Eq, Typeable, Ord)
instance Enum CqlResultType where
  fromEnum t = case t of
    ROWS -> 1
    VOID -> 2
    INT -> 3
  toEnum t = case t of
    1 -> ROWS
    2 -> VOID
    3 -> INT
    _ -> throw ThriftException
data Column = Column{f_Column_name :: Maybe ByteString,f_Column_value :: Maybe ByteString,f_Column_timestamp :: Maybe Int64,f_Column_ttl :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_Column oprot record = do
  writeStructBegin oprot "Column"
  case f_Column_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Column_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Column_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Column_ttl record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ttl",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Column_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_STRING then do
        s <- readBinary iprot
        read_Column_fields iprot record{f_Column_name=Just s}
        else do
          skip iprot _t3
          read_Column_fields iprot record
      2 -> if _t3 == T_STRING then do
        s <- readBinary iprot
        read_Column_fields iprot record{f_Column_value=Just s}
        else do
          skip iprot _t3
          read_Column_fields iprot record
      3 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Column_fields iprot record{f_Column_timestamp=Just s}
        else do
          skip iprot _t3
          read_Column_fields iprot record
      4 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_Column_fields iprot record{f_Column_ttl=Just s}
        else do
          skip iprot _t3
          read_Column_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Column_fields iprot record
read_Column iprot = do
  _ <- readStructBegin iprot
  record <- read_Column_fields iprot (Column{f_Column_name=Nothing,f_Column_value=Nothing,f_Column_timestamp=Nothing,f_Column_ttl=Nothing})
  readStructEnd iprot
  return record
data SuperColumn = SuperColumn{f_SuperColumn_name :: Maybe ByteString,f_SuperColumn_columns :: Maybe [Column]} deriving (Show,Eq,Ord,Typeable)
write_SuperColumn oprot record = do
  writeStructBegin oprot "SuperColumn"
  case f_SuperColumn_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_SuperColumn_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let {f [] = return (); f (_viter7:t) = do {write_Column oprot _viter7;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SuperColumn_fields iprot record = do
  (_,_t9,_id10) <- readFieldBegin iprot
  if _t9 == T_STOP then return record else
    case _id10 of 
      1 -> if _t9 == T_STRING then do
        s <- readBinary iprot
        read_SuperColumn_fields iprot record{f_SuperColumn_name=Just s}
        else do
          skip iprot _t9
          read_SuperColumn_fields iprot record
      2 -> if _t9 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Column iprot);r <- f (n-1); return $ v:r}} in do {(_etype14,_size11) <- readListBegin iprot; f _size11})
        read_SuperColumn_fields iprot record{f_SuperColumn_columns=Just s}
        else do
          skip iprot _t9
          read_SuperColumn_fields iprot record
      _ -> do
        skip iprot _t9
        readFieldEnd iprot
        read_SuperColumn_fields iprot record
read_SuperColumn iprot = do
  _ <- readStructBegin iprot
  record <- read_SuperColumn_fields iprot (SuperColumn{f_SuperColumn_name=Nothing,f_SuperColumn_columns=Nothing})
  readStructEnd iprot
  return record
data CounterColumn = CounterColumn{f_CounterColumn_name :: Maybe ByteString,f_CounterColumn_value :: Maybe Int64} deriving (Show,Eq,Ord,Typeable)
write_CounterColumn oprot record = do
  writeStructBegin oprot "CounterColumn"
  case f_CounterColumn_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CounterColumn_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CounterColumn_fields iprot record = do
  (_,_t19,_id20) <- readFieldBegin iprot
  if _t19 == T_STOP then return record else
    case _id20 of 
      1 -> if _t19 == T_STRING then do
        s <- readBinary iprot
        read_CounterColumn_fields iprot record{f_CounterColumn_name=Just s}
        else do
          skip iprot _t19
          read_CounterColumn_fields iprot record
      2 -> if _t19 == T_I64 then do
        s <- readI64 iprot
        read_CounterColumn_fields iprot record{f_CounterColumn_value=Just s}
        else do
          skip iprot _t19
          read_CounterColumn_fields iprot record
      _ -> do
        skip iprot _t19
        readFieldEnd iprot
        read_CounterColumn_fields iprot record
read_CounterColumn iprot = do
  _ <- readStructBegin iprot
  record <- read_CounterColumn_fields iprot (CounterColumn{f_CounterColumn_name=Nothing,f_CounterColumn_value=Nothing})
  readStructEnd iprot
  return record
data CounterSuperColumn = CounterSuperColumn{f_CounterSuperColumn_name :: Maybe ByteString,f_CounterSuperColumn_columns :: Maybe [CounterColumn]} deriving (Show,Eq,Ord,Typeable)
write_CounterSuperColumn oprot record = do
  writeStructBegin oprot "CounterSuperColumn"
  case f_CounterSuperColumn_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CounterSuperColumn_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let {f [] = return (); f (_viter23:t) = do {write_CounterColumn oprot _viter23;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CounterSuperColumn_fields iprot record = do
  (_,_t25,_id26) <- readFieldBegin iprot
  if _t25 == T_STOP then return record else
    case _id26 of 
      1 -> if _t25 == T_STRING then do
        s <- readBinary iprot
        read_CounterSuperColumn_fields iprot record{f_CounterSuperColumn_name=Just s}
        else do
          skip iprot _t25
          read_CounterSuperColumn_fields iprot record
      2 -> if _t25 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_CounterColumn iprot);r <- f (n-1); return $ v:r}} in do {(_etype30,_size27) <- readListBegin iprot; f _size27})
        read_CounterSuperColumn_fields iprot record{f_CounterSuperColumn_columns=Just s}
        else do
          skip iprot _t25
          read_CounterSuperColumn_fields iprot record
      _ -> do
        skip iprot _t25
        readFieldEnd iprot
        read_CounterSuperColumn_fields iprot record
read_CounterSuperColumn iprot = do
  _ <- readStructBegin iprot
  record <- read_CounterSuperColumn_fields iprot (CounterSuperColumn{f_CounterSuperColumn_name=Nothing,f_CounterSuperColumn_columns=Nothing})
  readStructEnd iprot
  return record
data ColumnOrSuperColumn = ColumnOrSuperColumn{f_ColumnOrSuperColumn_column :: Maybe Column,f_ColumnOrSuperColumn_super_column :: Maybe SuperColumn,f_ColumnOrSuperColumn_counter_column :: Maybe CounterColumn,f_ColumnOrSuperColumn_counter_super_column :: Maybe CounterSuperColumn} deriving (Show,Eq,Ord,Typeable)
write_ColumnOrSuperColumn oprot record = do
  writeStructBegin oprot "ColumnOrSuperColumn"
  case f_ColumnOrSuperColumn_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRUCT,1)
    write_Column oprot _v
    writeFieldEnd oprot}
  case f_ColumnOrSuperColumn_super_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("super_column",T_STRUCT,2)
    write_SuperColumn oprot _v
    writeFieldEnd oprot}
  case f_ColumnOrSuperColumn_counter_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("counter_column",T_STRUCT,3)
    write_CounterColumn oprot _v
    writeFieldEnd oprot}
  case f_ColumnOrSuperColumn_counter_super_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("counter_super_column",T_STRUCT,4)
    write_CounterSuperColumn oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnOrSuperColumn_fields iprot record = do
  (_,_t35,_id36) <- readFieldBegin iprot
  if _t35 == T_STOP then return record else
    case _id36 of 
      1 -> if _t35 == T_STRUCT then do
        s <- (read_Column iprot)
        read_ColumnOrSuperColumn_fields iprot record{f_ColumnOrSuperColumn_column=Just s}
        else do
          skip iprot _t35
          read_ColumnOrSuperColumn_fields iprot record
      2 -> if _t35 == T_STRUCT then do
        s <- (read_SuperColumn iprot)
        read_ColumnOrSuperColumn_fields iprot record{f_ColumnOrSuperColumn_super_column=Just s}
        else do
          skip iprot _t35
          read_ColumnOrSuperColumn_fields iprot record
      3 -> if _t35 == T_STRUCT then do
        s <- (read_CounterColumn iprot)
        read_ColumnOrSuperColumn_fields iprot record{f_ColumnOrSuperColumn_counter_column=Just s}
        else do
          skip iprot _t35
          read_ColumnOrSuperColumn_fields iprot record
      4 -> if _t35 == T_STRUCT then do
        s <- (read_CounterSuperColumn iprot)
        read_ColumnOrSuperColumn_fields iprot record{f_ColumnOrSuperColumn_counter_super_column=Just s}
        else do
          skip iprot _t35
          read_ColumnOrSuperColumn_fields iprot record
      _ -> do
        skip iprot _t35
        readFieldEnd iprot
        read_ColumnOrSuperColumn_fields iprot record
read_ColumnOrSuperColumn iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnOrSuperColumn_fields iprot (ColumnOrSuperColumn{f_ColumnOrSuperColumn_column=Nothing,f_ColumnOrSuperColumn_super_column=Nothing,f_ColumnOrSuperColumn_counter_column=Nothing,f_ColumnOrSuperColumn_counter_super_column=Nothing})
  readStructEnd iprot
  return record
data NotFoundException = NotFoundException deriving (Show,Eq,Ord,Typeable)
instance Exception NotFoundException
write_NotFoundException oprot record = do
  writeStructBegin oprot "NotFoundException"
  writeFieldStop oprot
  writeStructEnd oprot
read_NotFoundException_fields iprot record = do
  (_,_t40,_id41) <- readFieldBegin iprot
  if _t40 == T_STOP then return record else
    case _id41 of 
      _ -> do
        skip iprot _t40
        readFieldEnd iprot
        read_NotFoundException_fields iprot record
read_NotFoundException iprot = do
  _ <- readStructBegin iprot
  record <- read_NotFoundException_fields iprot (NotFoundException{})
  readStructEnd iprot
  return record
data InvalidRequestException = InvalidRequestException{f_InvalidRequestException_why :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception InvalidRequestException
write_InvalidRequestException oprot record = do
  writeStructBegin oprot "InvalidRequestException"
  case f_InvalidRequestException_why record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("why",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_InvalidRequestException_fields iprot record = do
  (_,_t45,_id46) <- readFieldBegin iprot
  if _t45 == T_STOP then return record else
    case _id46 of 
      1 -> if _t45 == T_STRING then do
        s <- readString iprot
        read_InvalidRequestException_fields iprot record{f_InvalidRequestException_why=Just s}
        else do
          skip iprot _t45
          read_InvalidRequestException_fields iprot record
      _ -> do
        skip iprot _t45
        readFieldEnd iprot
        read_InvalidRequestException_fields iprot record
read_InvalidRequestException iprot = do
  _ <- readStructBegin iprot
  record <- read_InvalidRequestException_fields iprot (InvalidRequestException{f_InvalidRequestException_why=Nothing})
  readStructEnd iprot
  return record
data UnavailableException = UnavailableException deriving (Show,Eq,Ord,Typeable)
instance Exception UnavailableException
write_UnavailableException oprot record = do
  writeStructBegin oprot "UnavailableException"
  writeFieldStop oprot
  writeStructEnd oprot
read_UnavailableException_fields iprot record = do
  (_,_t50,_id51) <- readFieldBegin iprot
  if _t50 == T_STOP then return record else
    case _id51 of 
      _ -> do
        skip iprot _t50
        readFieldEnd iprot
        read_UnavailableException_fields iprot record
read_UnavailableException iprot = do
  _ <- readStructBegin iprot
  record <- read_UnavailableException_fields iprot (UnavailableException{})
  readStructEnd iprot
  return record
data TimedOutException = TimedOutException deriving (Show,Eq,Ord,Typeable)
instance Exception TimedOutException
write_TimedOutException oprot record = do
  writeStructBegin oprot "TimedOutException"
  writeFieldStop oprot
  writeStructEnd oprot
read_TimedOutException_fields iprot record = do
  (_,_t55,_id56) <- readFieldBegin iprot
  if _t55 == T_STOP then return record else
    case _id56 of 
      _ -> do
        skip iprot _t55
        readFieldEnd iprot
        read_TimedOutException_fields iprot record
read_TimedOutException iprot = do
  _ <- readStructBegin iprot
  record <- read_TimedOutException_fields iprot (TimedOutException{})
  readStructEnd iprot
  return record
data AuthenticationException = AuthenticationException{f_AuthenticationException_why :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception AuthenticationException
write_AuthenticationException oprot record = do
  writeStructBegin oprot "AuthenticationException"
  case f_AuthenticationException_why record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("why",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AuthenticationException_fields iprot record = do
  (_,_t60,_id61) <- readFieldBegin iprot
  if _t60 == T_STOP then return record else
    case _id61 of 
      1 -> if _t60 == T_STRING then do
        s <- readString iprot
        read_AuthenticationException_fields iprot record{f_AuthenticationException_why=Just s}
        else do
          skip iprot _t60
          read_AuthenticationException_fields iprot record
      _ -> do
        skip iprot _t60
        readFieldEnd iprot
        read_AuthenticationException_fields iprot record
read_AuthenticationException iprot = do
  _ <- readStructBegin iprot
  record <- read_AuthenticationException_fields iprot (AuthenticationException{f_AuthenticationException_why=Nothing})
  readStructEnd iprot
  return record
data AuthorizationException = AuthorizationException{f_AuthorizationException_why :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception AuthorizationException
write_AuthorizationException oprot record = do
  writeStructBegin oprot "AuthorizationException"
  case f_AuthorizationException_why record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("why",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AuthorizationException_fields iprot record = do
  (_,_t65,_id66) <- readFieldBegin iprot
  if _t65 == T_STOP then return record else
    case _id66 of 
      1 -> if _t65 == T_STRING then do
        s <- readString iprot
        read_AuthorizationException_fields iprot record{f_AuthorizationException_why=Just s}
        else do
          skip iprot _t65
          read_AuthorizationException_fields iprot record
      _ -> do
        skip iprot _t65
        readFieldEnd iprot
        read_AuthorizationException_fields iprot record
read_AuthorizationException iprot = do
  _ <- readStructBegin iprot
  record <- read_AuthorizationException_fields iprot (AuthorizationException{f_AuthorizationException_why=Nothing})
  readStructEnd iprot
  return record
data SchemaDisagreementException = SchemaDisagreementException deriving (Show,Eq,Ord,Typeable)
instance Exception SchemaDisagreementException
write_SchemaDisagreementException oprot record = do
  writeStructBegin oprot "SchemaDisagreementException"
  writeFieldStop oprot
  writeStructEnd oprot
read_SchemaDisagreementException_fields iprot record = do
  (_,_t70,_id71) <- readFieldBegin iprot
  if _t70 == T_STOP then return record else
    case _id71 of 
      _ -> do
        skip iprot _t70
        readFieldEnd iprot
        read_SchemaDisagreementException_fields iprot record
read_SchemaDisagreementException iprot = do
  _ <- readStructBegin iprot
  record <- read_SchemaDisagreementException_fields iprot (SchemaDisagreementException{})
  readStructEnd iprot
  return record
data ColumnParent = ColumnParent{f_ColumnParent_column_family :: Maybe String,f_ColumnParent_super_column :: Maybe ByteString} deriving (Show,Eq,Ord,Typeable)
write_ColumnParent oprot record = do
  writeStructBegin oprot "ColumnParent"
  case f_ColumnParent_column_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_family",T_STRING,3)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ColumnParent_super_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("super_column",T_STRING,4)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnParent_fields iprot record = do
  (_,_t75,_id76) <- readFieldBegin iprot
  if _t75 == T_STOP then return record else
    case _id76 of 
      3 -> if _t75 == T_STRING then do
        s <- readString iprot
        read_ColumnParent_fields iprot record{f_ColumnParent_column_family=Just s}
        else do
          skip iprot _t75
          read_ColumnParent_fields iprot record
      4 -> if _t75 == T_STRING then do
        s <- readBinary iprot
        read_ColumnParent_fields iprot record{f_ColumnParent_super_column=Just s}
        else do
          skip iprot _t75
          read_ColumnParent_fields iprot record
      _ -> do
        skip iprot _t75
        readFieldEnd iprot
        read_ColumnParent_fields iprot record
read_ColumnParent iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnParent_fields iprot (ColumnParent{f_ColumnParent_column_family=Nothing,f_ColumnParent_super_column=Nothing})
  readStructEnd iprot
  return record
data ColumnPath = ColumnPath{f_ColumnPath_column_family :: Maybe String,f_ColumnPath_super_column :: Maybe ByteString,f_ColumnPath_column :: Maybe ByteString} deriving (Show,Eq,Ord,Typeable)
write_ColumnPath oprot record = do
  writeStructBegin oprot "ColumnPath"
  case f_ColumnPath_column_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_family",T_STRING,3)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ColumnPath_super_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("super_column",T_STRING,4)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ColumnPath_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,5)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnPath_fields iprot record = do
  (_,_t80,_id81) <- readFieldBegin iprot
  if _t80 == T_STOP then return record else
    case _id81 of 
      3 -> if _t80 == T_STRING then do
        s <- readString iprot
        read_ColumnPath_fields iprot record{f_ColumnPath_column_family=Just s}
        else do
          skip iprot _t80
          read_ColumnPath_fields iprot record
      4 -> if _t80 == T_STRING then do
        s <- readBinary iprot
        read_ColumnPath_fields iprot record{f_ColumnPath_super_column=Just s}
        else do
          skip iprot _t80
          read_ColumnPath_fields iprot record
      5 -> if _t80 == T_STRING then do
        s <- readBinary iprot
        read_ColumnPath_fields iprot record{f_ColumnPath_column=Just s}
        else do
          skip iprot _t80
          read_ColumnPath_fields iprot record
      _ -> do
        skip iprot _t80
        readFieldEnd iprot
        read_ColumnPath_fields iprot record
read_ColumnPath iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnPath_fields iprot (ColumnPath{f_ColumnPath_column_family=Nothing,f_ColumnPath_super_column=Nothing,f_ColumnPath_column=Nothing})
  readStructEnd iprot
  return record
data SliceRange = SliceRange{f_SliceRange_start :: Maybe ByteString,f_SliceRange_finish :: Maybe ByteString,f_SliceRange_reversed :: Maybe Bool,f_SliceRange_count :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_SliceRange oprot record = do
  writeStructBegin oprot "SliceRange"
  case f_SliceRange_start record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("start",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_SliceRange_finish record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("finish",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_SliceRange_reversed record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("reversed",T_BOOL,3)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_SliceRange_count record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("count",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SliceRange_fields iprot record = do
  (_,_t85,_id86) <- readFieldBegin iprot
  if _t85 == T_STOP then return record else
    case _id86 of 
      1 -> if _t85 == T_STRING then do
        s <- readBinary iprot
        read_SliceRange_fields iprot record{f_SliceRange_start=Just s}
        else do
          skip iprot _t85
          read_SliceRange_fields iprot record
      2 -> if _t85 == T_STRING then do
        s <- readBinary iprot
        read_SliceRange_fields iprot record{f_SliceRange_finish=Just s}
        else do
          skip iprot _t85
          read_SliceRange_fields iprot record
      3 -> if _t85 == T_BOOL then do
        s <- readBool iprot
        read_SliceRange_fields iprot record{f_SliceRange_reversed=Just s}
        else do
          skip iprot _t85
          read_SliceRange_fields iprot record
      4 -> if _t85 == T_I32 then do
        s <- readI32 iprot
        read_SliceRange_fields iprot record{f_SliceRange_count=Just s}
        else do
          skip iprot _t85
          read_SliceRange_fields iprot record
      _ -> do
        skip iprot _t85
        readFieldEnd iprot
        read_SliceRange_fields iprot record
read_SliceRange iprot = do
  _ <- readStructBegin iprot
  record <- read_SliceRange_fields iprot (SliceRange{f_SliceRange_start=Nothing,f_SliceRange_finish=Nothing,f_SliceRange_reversed=Nothing,f_SliceRange_count=Nothing})
  readStructEnd iprot
  return record
data SlicePredicate = SlicePredicate{f_SlicePredicate_column_names :: Maybe [ByteString],f_SlicePredicate_slice_range :: Maybe SliceRange} deriving (Show,Eq,Ord,Typeable)
write_SlicePredicate oprot record = do
  writeStructBegin oprot "SlicePredicate"
  case f_SlicePredicate_column_names record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_names",T_LIST,1)
    (let {f [] = return (); f (_viter89:t) = do {writeBinary oprot _viter89;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SlicePredicate_slice_range record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("slice_range",T_STRUCT,2)
    write_SliceRange oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SlicePredicate_fields iprot record = do
  (_,_t91,_id92) <- readFieldBegin iprot
  if _t91 == T_STOP then return record else
    case _id92 of 
      1 -> if _t91 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readBinary iprot;r <- f (n-1); return $ v:r}} in do {(_etype96,_size93) <- readListBegin iprot; f _size93})
        read_SlicePredicate_fields iprot record{f_SlicePredicate_column_names=Just s}
        else do
          skip iprot _t91
          read_SlicePredicate_fields iprot record
      2 -> if _t91 == T_STRUCT then do
        s <- (read_SliceRange iprot)
        read_SlicePredicate_fields iprot record{f_SlicePredicate_slice_range=Just s}
        else do
          skip iprot _t91
          read_SlicePredicate_fields iprot record
      _ -> do
        skip iprot _t91
        readFieldEnd iprot
        read_SlicePredicate_fields iprot record
read_SlicePredicate iprot = do
  _ <- readStructBegin iprot
  record <- read_SlicePredicate_fields iprot (SlicePredicate{f_SlicePredicate_column_names=Nothing,f_SlicePredicate_slice_range=Nothing})
  readStructEnd iprot
  return record
data IndexExpression = IndexExpression{f_IndexExpression_column_name :: Maybe ByteString,f_IndexExpression_op :: Maybe IndexOperator,f_IndexExpression_value :: Maybe ByteString} deriving (Show,Eq,Ord,Typeable)
write_IndexExpression oprot record = do
  writeStructBegin oprot "IndexExpression"
  case f_IndexExpression_column_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_IndexExpression_op record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("op",T_I32,2)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_IndexExpression_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IndexExpression_fields iprot record = do
  (_,_t101,_id102) <- readFieldBegin iprot
  if _t101 == T_STOP then return record else
    case _id102 of 
      1 -> if _t101 == T_STRING then do
        s <- readBinary iprot
        read_IndexExpression_fields iprot record{f_IndexExpression_column_name=Just s}
        else do
          skip iprot _t101
          read_IndexExpression_fields iprot record
      2 -> if _t101 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_IndexExpression_fields iprot record{f_IndexExpression_op=Just s}
        else do
          skip iprot _t101
          read_IndexExpression_fields iprot record
      3 -> if _t101 == T_STRING then do
        s <- readBinary iprot
        read_IndexExpression_fields iprot record{f_IndexExpression_value=Just s}
        else do
          skip iprot _t101
          read_IndexExpression_fields iprot record
      _ -> do
        skip iprot _t101
        readFieldEnd iprot
        read_IndexExpression_fields iprot record
read_IndexExpression iprot = do
  _ <- readStructBegin iprot
  record <- read_IndexExpression_fields iprot (IndexExpression{f_IndexExpression_column_name=Nothing,f_IndexExpression_op=Nothing,f_IndexExpression_value=Nothing})
  readStructEnd iprot
  return record
data IndexClause = IndexClause{f_IndexClause_expressions :: Maybe [IndexExpression],f_IndexClause_start_key :: Maybe ByteString,f_IndexClause_count :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_IndexClause oprot record = do
  writeStructBegin oprot "IndexClause"
  case f_IndexClause_expressions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expressions",T_LIST,1)
    (let {f [] = return (); f (_viter105:t) = do {write_IndexExpression oprot _viter105;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_IndexClause_start_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("start_key",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_IndexClause_count record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("count",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IndexClause_fields iprot record = do
  (_,_t107,_id108) <- readFieldBegin iprot
  if _t107 == T_STOP then return record else
    case _id108 of 
      1 -> if _t107 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_IndexExpression iprot);r <- f (n-1); return $ v:r}} in do {(_etype112,_size109) <- readListBegin iprot; f _size109})
        read_IndexClause_fields iprot record{f_IndexClause_expressions=Just s}
        else do
          skip iprot _t107
          read_IndexClause_fields iprot record
      2 -> if _t107 == T_STRING then do
        s <- readBinary iprot
        read_IndexClause_fields iprot record{f_IndexClause_start_key=Just s}
        else do
          skip iprot _t107
          read_IndexClause_fields iprot record
      3 -> if _t107 == T_I32 then do
        s <- readI32 iprot
        read_IndexClause_fields iprot record{f_IndexClause_count=Just s}
        else do
          skip iprot _t107
          read_IndexClause_fields iprot record
      _ -> do
        skip iprot _t107
        readFieldEnd iprot
        read_IndexClause_fields iprot record
read_IndexClause iprot = do
  _ <- readStructBegin iprot
  record <- read_IndexClause_fields iprot (IndexClause{f_IndexClause_expressions=Nothing,f_IndexClause_start_key=Nothing,f_IndexClause_count=Nothing})
  readStructEnd iprot
  return record
data KeyRange = KeyRange{f_KeyRange_start_key :: Maybe ByteString,f_KeyRange_end_key :: Maybe ByteString,f_KeyRange_start_token :: Maybe String,f_KeyRange_end_token :: Maybe String,f_KeyRange_count :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_KeyRange oprot record = do
  writeStructBegin oprot "KeyRange"
  case f_KeyRange_start_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("start_key",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_KeyRange_end_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("end_key",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_KeyRange_start_token record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("start_token",T_STRING,3)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_KeyRange_end_token record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("end_token",T_STRING,4)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_KeyRange_count record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("count",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_KeyRange_fields iprot record = do
  (_,_t117,_id118) <- readFieldBegin iprot
  if _t117 == T_STOP then return record else
    case _id118 of 
      1 -> if _t117 == T_STRING then do
        s <- readBinary iprot
        read_KeyRange_fields iprot record{f_KeyRange_start_key=Just s}
        else do
          skip iprot _t117
          read_KeyRange_fields iprot record
      2 -> if _t117 == T_STRING then do
        s <- readBinary iprot
        read_KeyRange_fields iprot record{f_KeyRange_end_key=Just s}
        else do
          skip iprot _t117
          read_KeyRange_fields iprot record
      3 -> if _t117 == T_STRING then do
        s <- readString iprot
        read_KeyRange_fields iprot record{f_KeyRange_start_token=Just s}
        else do
          skip iprot _t117
          read_KeyRange_fields iprot record
      4 -> if _t117 == T_STRING then do
        s <- readString iprot
        read_KeyRange_fields iprot record{f_KeyRange_end_token=Just s}
        else do
          skip iprot _t117
          read_KeyRange_fields iprot record
      5 -> if _t117 == T_I32 then do
        s <- readI32 iprot
        read_KeyRange_fields iprot record{f_KeyRange_count=Just s}
        else do
          skip iprot _t117
          read_KeyRange_fields iprot record
      _ -> do
        skip iprot _t117
        readFieldEnd iprot
        read_KeyRange_fields iprot record
read_KeyRange iprot = do
  _ <- readStructBegin iprot
  record <- read_KeyRange_fields iprot (KeyRange{f_KeyRange_start_key=Nothing,f_KeyRange_end_key=Nothing,f_KeyRange_start_token=Nothing,f_KeyRange_end_token=Nothing,f_KeyRange_count=Nothing})
  readStructEnd iprot
  return record
data KeySlice = KeySlice{f_KeySlice_key :: Maybe ByteString,f_KeySlice_columns :: Maybe [ColumnOrSuperColumn]} deriving (Show,Eq,Ord,Typeable)
write_KeySlice oprot record = do
  writeStructBegin oprot "KeySlice"
  case f_KeySlice_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_KeySlice_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let {f [] = return (); f (_viter121:t) = do {write_ColumnOrSuperColumn oprot _viter121;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_KeySlice_fields iprot record = do
  (_,_t123,_id124) <- readFieldBegin iprot
  if _t123 == T_STOP then return record else
    case _id124 of 
      1 -> if _t123 == T_STRING then do
        s <- readBinary iprot
        read_KeySlice_fields iprot record{f_KeySlice_key=Just s}
        else do
          skip iprot _t123
          read_KeySlice_fields iprot record
      2 -> if _t123 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_ColumnOrSuperColumn iprot);r <- f (n-1); return $ v:r}} in do {(_etype128,_size125) <- readListBegin iprot; f _size125})
        read_KeySlice_fields iprot record{f_KeySlice_columns=Just s}
        else do
          skip iprot _t123
          read_KeySlice_fields iprot record
      _ -> do
        skip iprot _t123
        readFieldEnd iprot
        read_KeySlice_fields iprot record
read_KeySlice iprot = do
  _ <- readStructBegin iprot
  record <- read_KeySlice_fields iprot (KeySlice{f_KeySlice_key=Nothing,f_KeySlice_columns=Nothing})
  readStructEnd iprot
  return record
data KeyCount = KeyCount{f_KeyCount_key :: Maybe ByteString,f_KeyCount_count :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_KeyCount oprot record = do
  writeStructBegin oprot "KeyCount"
  case f_KeyCount_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_KeyCount_count record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("count",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_KeyCount_fields iprot record = do
  (_,_t133,_id134) <- readFieldBegin iprot
  if _t133 == T_STOP then return record else
    case _id134 of 
      1 -> if _t133 == T_STRING then do
        s <- readBinary iprot
        read_KeyCount_fields iprot record{f_KeyCount_key=Just s}
        else do
          skip iprot _t133
          read_KeyCount_fields iprot record
      2 -> if _t133 == T_I32 then do
        s <- readI32 iprot
        read_KeyCount_fields iprot record{f_KeyCount_count=Just s}
        else do
          skip iprot _t133
          read_KeyCount_fields iprot record
      _ -> do
        skip iprot _t133
        readFieldEnd iprot
        read_KeyCount_fields iprot record
read_KeyCount iprot = do
  _ <- readStructBegin iprot
  record <- read_KeyCount_fields iprot (KeyCount{f_KeyCount_key=Nothing,f_KeyCount_count=Nothing})
  readStructEnd iprot
  return record
data Deletion = Deletion{f_Deletion_timestamp :: Maybe Int64,f_Deletion_super_column :: Maybe ByteString,f_Deletion_predicate :: Maybe SlicePredicate} deriving (Show,Eq,Ord,Typeable)
write_Deletion oprot record = do
  writeStructBegin oprot "Deletion"
  case f_Deletion_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Deletion_super_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("super_column",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Deletion_predicate record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("predicate",T_STRUCT,3)
    write_SlicePredicate oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Deletion_fields iprot record = do
  (_,_t138,_id139) <- readFieldBegin iprot
  if _t138 == T_STOP then return record else
    case _id139 of 
      1 -> if _t138 == T_I64 then do
        s <- readI64 iprot
        read_Deletion_fields iprot record{f_Deletion_timestamp=Just s}
        else do
          skip iprot _t138
          read_Deletion_fields iprot record
      2 -> if _t138 == T_STRING then do
        s <- readBinary iprot
        read_Deletion_fields iprot record{f_Deletion_super_column=Just s}
        else do
          skip iprot _t138
          read_Deletion_fields iprot record
      3 -> if _t138 == T_STRUCT then do
        s <- (read_SlicePredicate iprot)
        read_Deletion_fields iprot record{f_Deletion_predicate=Just s}
        else do
          skip iprot _t138
          read_Deletion_fields iprot record
      _ -> do
        skip iprot _t138
        readFieldEnd iprot
        read_Deletion_fields iprot record
read_Deletion iprot = do
  _ <- readStructBegin iprot
  record <- read_Deletion_fields iprot (Deletion{f_Deletion_timestamp=Nothing,f_Deletion_super_column=Nothing,f_Deletion_predicate=Nothing})
  readStructEnd iprot
  return record
data Mutation = Mutation{f_Mutation_column_or_supercolumn :: Maybe ColumnOrSuperColumn,f_Mutation_deletion :: Maybe Deletion} deriving (Show,Eq,Ord,Typeable)
write_Mutation oprot record = do
  writeStructBegin oprot "Mutation"
  case f_Mutation_column_or_supercolumn record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_or_supercolumn",T_STRUCT,1)
    write_ColumnOrSuperColumn oprot _v
    writeFieldEnd oprot}
  case f_Mutation_deletion record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deletion",T_STRUCT,2)
    write_Deletion oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Mutation_fields iprot record = do
  (_,_t143,_id144) <- readFieldBegin iprot
  if _t143 == T_STOP then return record else
    case _id144 of 
      1 -> if _t143 == T_STRUCT then do
        s <- (read_ColumnOrSuperColumn iprot)
        read_Mutation_fields iprot record{f_Mutation_column_or_supercolumn=Just s}
        else do
          skip iprot _t143
          read_Mutation_fields iprot record
      2 -> if _t143 == T_STRUCT then do
        s <- (read_Deletion iprot)
        read_Mutation_fields iprot record{f_Mutation_deletion=Just s}
        else do
          skip iprot _t143
          read_Mutation_fields iprot record
      _ -> do
        skip iprot _t143
        readFieldEnd iprot
        read_Mutation_fields iprot record
read_Mutation iprot = do
  _ <- readStructBegin iprot
  record <- read_Mutation_fields iprot (Mutation{f_Mutation_column_or_supercolumn=Nothing,f_Mutation_deletion=Nothing})
  readStructEnd iprot
  return record
data TokenRange = TokenRange{f_TokenRange_start_token :: Maybe String,f_TokenRange_end_token :: Maybe String,f_TokenRange_endpoints :: Maybe [String]} deriving (Show,Eq,Ord,Typeable)
write_TokenRange oprot record = do
  writeStructBegin oprot "TokenRange"
  case f_TokenRange_start_token record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("start_token",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_TokenRange_end_token record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("end_token",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_TokenRange_endpoints record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("endpoints",T_LIST,3)
    (let {f [] = return (); f (_viter147:t) = do {writeString oprot _viter147;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TokenRange_fields iprot record = do
  (_,_t149,_id150) <- readFieldBegin iprot
  if _t149 == T_STOP then return record else
    case _id150 of 
      1 -> if _t149 == T_STRING then do
        s <- readString iprot
        read_TokenRange_fields iprot record{f_TokenRange_start_token=Just s}
        else do
          skip iprot _t149
          read_TokenRange_fields iprot record
      2 -> if _t149 == T_STRING then do
        s <- readString iprot
        read_TokenRange_fields iprot record{f_TokenRange_end_token=Just s}
        else do
          skip iprot _t149
          read_TokenRange_fields iprot record
      3 -> if _t149 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype154,_size151) <- readListBegin iprot; f _size151})
        read_TokenRange_fields iprot record{f_TokenRange_endpoints=Just s}
        else do
          skip iprot _t149
          read_TokenRange_fields iprot record
      _ -> do
        skip iprot _t149
        readFieldEnd iprot
        read_TokenRange_fields iprot record
read_TokenRange iprot = do
  _ <- readStructBegin iprot
  record <- read_TokenRange_fields iprot (TokenRange{f_TokenRange_start_token=Nothing,f_TokenRange_end_token=Nothing,f_TokenRange_endpoints=Nothing})
  readStructEnd iprot
  return record
data AuthenticationRequest = AuthenticationRequest{f_AuthenticationRequest_credentials :: Maybe (Map.Map String String)} deriving (Show,Eq,Ord,Typeable)
write_AuthenticationRequest oprot record = do
  writeStructBegin oprot "AuthenticationRequest"
  case f_AuthenticationRequest_credentials record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("credentials",T_MAP,1)
    (let {f [] = return (); f ((_kiter158,_viter159):t) = do {do {writeString oprot _kiter158;writeString oprot _viter159};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AuthenticationRequest_fields iprot record = do
  (_,_t161,_id162) <- readFieldBegin iprot
  if _t161 == T_STOP then return record else
    case _id162 of 
      1 -> if _t161 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- readString iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype164,_vtype165,_size163) <- readMapBegin iprot; l <- f _size163; return $ Map.fromList l})
        read_AuthenticationRequest_fields iprot record{f_AuthenticationRequest_credentials=Just s}
        else do
          skip iprot _t161
          read_AuthenticationRequest_fields iprot record
      _ -> do
        skip iprot _t161
        readFieldEnd iprot
        read_AuthenticationRequest_fields iprot record
read_AuthenticationRequest iprot = do
  _ <- readStructBegin iprot
  record <- read_AuthenticationRequest_fields iprot (AuthenticationRequest{f_AuthenticationRequest_credentials=Nothing})
  readStructEnd iprot
  return record
data ColumnDef = ColumnDef{f_ColumnDef_name :: Maybe ByteString,f_ColumnDef_validation_class :: Maybe String,f_ColumnDef_index_type :: Maybe IndexType,f_ColumnDef_index_name :: Maybe String} deriving (Show,Eq,Ord,Typeable)
write_ColumnDef oprot record = do
  writeStructBegin oprot "ColumnDef"
  case f_ColumnDef_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ColumnDef_validation_class record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("validation_class",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ColumnDef_index_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("index_type",T_I32,3)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_ColumnDef_index_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("index_name",T_STRING,4)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnDef_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      1 -> if _t171 == T_STRING then do
        s <- readBinary iprot
        read_ColumnDef_fields iprot record{f_ColumnDef_name=Just s}
        else do
          skip iprot _t171
          read_ColumnDef_fields iprot record
      2 -> if _t171 == T_STRING then do
        s <- readString iprot
        read_ColumnDef_fields iprot record{f_ColumnDef_validation_class=Just s}
        else do
          skip iprot _t171
          read_ColumnDef_fields iprot record
      3 -> if _t171 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_ColumnDef_fields iprot record{f_ColumnDef_index_type=Just s}
        else do
          skip iprot _t171
          read_ColumnDef_fields iprot record
      4 -> if _t171 == T_STRING then do
        s <- readString iprot
        read_ColumnDef_fields iprot record{f_ColumnDef_index_name=Just s}
        else do
          skip iprot _t171
          read_ColumnDef_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_ColumnDef_fields iprot record
read_ColumnDef iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnDef_fields iprot (ColumnDef{f_ColumnDef_name=Nothing,f_ColumnDef_validation_class=Nothing,f_ColumnDef_index_type=Nothing,f_ColumnDef_index_name=Nothing})
  readStructEnd iprot
  return record
data CfDef = CfDef{f_CfDef_keyspace :: Maybe String,f_CfDef_name :: Maybe String,f_CfDef_column_type :: Maybe String,f_CfDef_comparator_type :: Maybe String,f_CfDef_subcomparator_type :: Maybe String,f_CfDef_comment :: Maybe String,f_CfDef_row_cache_size :: Maybe Double,f_CfDef_key_cache_size :: Maybe Double,f_CfDef_read_repair_chance :: Maybe Double,f_CfDef_column_metadata :: Maybe [ColumnDef],f_CfDef_gc_grace_seconds :: Maybe Int32,f_CfDef_default_validation_class :: Maybe String,f_CfDef_id :: Maybe Int32,f_CfDef_min_compaction_threshold :: Maybe Int32,f_CfDef_max_compaction_threshold :: Maybe Int32,f_CfDef_row_cache_save_period_in_seconds :: Maybe Int32,f_CfDef_key_cache_save_period_in_seconds :: Maybe Int32,f_CfDef_memtable_flush_after_mins :: Maybe Int32,f_CfDef_memtable_throughput_in_mb :: Maybe Int32,f_CfDef_memtable_operations_in_millions :: Maybe Double,f_CfDef_replicate_on_write :: Maybe Bool,f_CfDef_merge_shards_chance :: Maybe Double,f_CfDef_key_validation_class :: Maybe String,f_CfDef_row_cache_provider :: Maybe String,f_CfDef_key_alias :: Maybe ByteString} deriving (Show,Eq,Ord,Typeable)
write_CfDef oprot record = do
  writeStructBegin oprot "CfDef"
  case f_CfDef_keyspace record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("keyspace",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_column_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_type",T_STRING,3)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_comparator_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("comparator_type",T_STRING,5)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_subcomparator_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("subcomparator_type",T_STRING,6)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_comment record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("comment",T_STRING,8)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_row_cache_size record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row_cache_size",T_DOUBLE,9)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_CfDef_key_cache_size record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key_cache_size",T_DOUBLE,11)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_CfDef_read_repair_chance record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("read_repair_chance",T_DOUBLE,12)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_CfDef_column_metadata record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column_metadata",T_LIST,13)
    (let {f [] = return (); f (_viter175:t) = do {write_ColumnDef oprot _viter175;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_CfDef_gc_grace_seconds record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("gc_grace_seconds",T_I32,14)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_default_validation_class record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("default_validation_class",T_STRING,15)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_id record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("id",T_I32,16)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_min_compaction_threshold record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("min_compaction_threshold",T_I32,17)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_max_compaction_threshold record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("max_compaction_threshold",T_I32,18)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_row_cache_save_period_in_seconds record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row_cache_save_period_in_seconds",T_I32,19)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_key_cache_save_period_in_seconds record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key_cache_save_period_in_seconds",T_I32,20)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_memtable_flush_after_mins record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("memtable_flush_after_mins",T_I32,21)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_memtable_throughput_in_mb record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("memtable_throughput_in_mb",T_I32,22)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_CfDef_memtable_operations_in_millions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("memtable_operations_in_millions",T_DOUBLE,23)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_CfDef_replicate_on_write record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("replicate_on_write",T_BOOL,24)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_CfDef_merge_shards_chance record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("merge_shards_chance",T_DOUBLE,25)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_CfDef_key_validation_class record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key_validation_class",T_STRING,26)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_row_cache_provider record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row_cache_provider",T_STRING,27)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_CfDef_key_alias record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key_alias",T_STRING,28)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CfDef_fields iprot record = do
  (_,_t177,_id178) <- readFieldBegin iprot
  if _t177 == T_STOP then return record else
    case _id178 of 
      1 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_keyspace=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      2 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_name=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      3 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_column_type=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      5 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_comparator_type=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      6 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_subcomparator_type=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      8 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_comment=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      9 -> if _t177 == T_DOUBLE then do
        s <- readDouble iprot
        read_CfDef_fields iprot record{f_CfDef_row_cache_size=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      11 -> if _t177 == T_DOUBLE then do
        s <- readDouble iprot
        read_CfDef_fields iprot record{f_CfDef_key_cache_size=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      12 -> if _t177 == T_DOUBLE then do
        s <- readDouble iprot
        read_CfDef_fields iprot record{f_CfDef_read_repair_chance=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      13 -> if _t177 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_ColumnDef iprot);r <- f (n-1); return $ v:r}} in do {(_etype182,_size179) <- readListBegin iprot; f _size179})
        read_CfDef_fields iprot record{f_CfDef_column_metadata=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      14 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_gc_grace_seconds=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      15 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_default_validation_class=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      16 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_id=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      17 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_min_compaction_threshold=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      18 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_max_compaction_threshold=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      19 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_row_cache_save_period_in_seconds=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      20 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_key_cache_save_period_in_seconds=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      21 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_memtable_flush_after_mins=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      22 -> if _t177 == T_I32 then do
        s <- readI32 iprot
        read_CfDef_fields iprot record{f_CfDef_memtable_throughput_in_mb=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      23 -> if _t177 == T_DOUBLE then do
        s <- readDouble iprot
        read_CfDef_fields iprot record{f_CfDef_memtable_operations_in_millions=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      24 -> if _t177 == T_BOOL then do
        s <- readBool iprot
        read_CfDef_fields iprot record{f_CfDef_replicate_on_write=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      25 -> if _t177 == T_DOUBLE then do
        s <- readDouble iprot
        read_CfDef_fields iprot record{f_CfDef_merge_shards_chance=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      26 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_key_validation_class=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      27 -> if _t177 == T_STRING then do
        s <- readString iprot
        read_CfDef_fields iprot record{f_CfDef_row_cache_provider=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      28 -> if _t177 == T_STRING then do
        s <- readBinary iprot
        read_CfDef_fields iprot record{f_CfDef_key_alias=Just s}
        else do
          skip iprot _t177
          read_CfDef_fields iprot record
      _ -> do
        skip iprot _t177
        readFieldEnd iprot
        read_CfDef_fields iprot record
read_CfDef iprot = do
  _ <- readStructBegin iprot
  record <- read_CfDef_fields iprot (CfDef{f_CfDef_keyspace=Nothing,f_CfDef_name=Nothing,f_CfDef_column_type=Nothing,f_CfDef_comparator_type=Nothing,f_CfDef_subcomparator_type=Nothing,f_CfDef_comment=Nothing,f_CfDef_row_cache_size=Nothing,f_CfDef_key_cache_size=Nothing,f_CfDef_read_repair_chance=Nothing,f_CfDef_column_metadata=Nothing,f_CfDef_gc_grace_seconds=Nothing,f_CfDef_default_validation_class=Nothing,f_CfDef_id=Nothing,f_CfDef_min_compaction_threshold=Nothing,f_CfDef_max_compaction_threshold=Nothing,f_CfDef_row_cache_save_period_in_seconds=Nothing,f_CfDef_key_cache_save_period_in_seconds=Nothing,f_CfDef_memtable_flush_after_mins=Nothing,f_CfDef_memtable_throughput_in_mb=Nothing,f_CfDef_memtable_operations_in_millions=Nothing,f_CfDef_replicate_on_write=Nothing,f_CfDef_merge_shards_chance=Nothing,f_CfDef_key_validation_class=Nothing,f_CfDef_row_cache_provider=Nothing,f_CfDef_key_alias=Nothing})
  readStructEnd iprot
  return record
data KsDef = KsDef{f_KsDef_name :: Maybe String,f_KsDef_strategy_class :: Maybe String,f_KsDef_strategy_options :: Maybe (Map.Map String String),f_KsDef_replication_factor :: Maybe Int32,f_KsDef_cf_defs :: Maybe [CfDef],f_KsDef_durable_writes :: Maybe Bool} deriving (Show,Eq,Ord,Typeable)
write_KsDef oprot record = do
  writeStructBegin oprot "KsDef"
  case f_KsDef_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_KsDef_strategy_class record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("strategy_class",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_KsDef_strategy_options record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("strategy_options",T_MAP,3)
    (let {f [] = return (); f ((_kiter186,_viter187):t) = do {do {writeString oprot _kiter186;writeString oprot _viter187};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_KsDef_replication_factor record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("replication_factor",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_KsDef_cf_defs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cf_defs",T_LIST,5)
    (let {f [] = return (); f (_viter188:t) = do {write_CfDef oprot _viter188;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_KsDef_durable_writes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("durable_writes",T_BOOL,6)
    writeBool oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_KsDef_fields iprot record = do
  (_,_t190,_id191) <- readFieldBegin iprot
  if _t190 == T_STOP then return record else
    case _id191 of 
      1 -> if _t190 == T_STRING then do
        s <- readString iprot
        read_KsDef_fields iprot record{f_KsDef_name=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      2 -> if _t190 == T_STRING then do
        s <- readString iprot
        read_KsDef_fields iprot record{f_KsDef_strategy_class=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      3 -> if _t190 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- readString iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype193,_vtype194,_size192) <- readMapBegin iprot; l <- f _size192; return $ Map.fromList l})
        read_KsDef_fields iprot record{f_KsDef_strategy_options=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      4 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_KsDef_fields iprot record{f_KsDef_replication_factor=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      5 -> if _t190 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_CfDef iprot);r <- f (n-1); return $ v:r}} in do {(_etype200,_size197) <- readListBegin iprot; f _size197})
        read_KsDef_fields iprot record{f_KsDef_cf_defs=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      6 -> if _t190 == T_BOOL then do
        s <- readBool iprot
        read_KsDef_fields iprot record{f_KsDef_durable_writes=Just s}
        else do
          skip iprot _t190
          read_KsDef_fields iprot record
      _ -> do
        skip iprot _t190
        readFieldEnd iprot
        read_KsDef_fields iprot record
read_KsDef iprot = do
  _ <- readStructBegin iprot
  record <- read_KsDef_fields iprot (KsDef{f_KsDef_name=Nothing,f_KsDef_strategy_class=Nothing,f_KsDef_strategy_options=Nothing,f_KsDef_replication_factor=Nothing,f_KsDef_cf_defs=Nothing,f_KsDef_durable_writes=Nothing})
  readStructEnd iprot
  return record
data CqlRow = CqlRow{f_CqlRow_key :: Maybe ByteString,f_CqlRow_columns :: Maybe [Column]} deriving (Show,Eq,Ord,Typeable)
write_CqlRow oprot record = do
  writeStructBegin oprot "CqlRow"
  case f_CqlRow_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CqlRow_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let {f [] = return (); f (_viter204:t) = do {write_Column oprot _viter204;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CqlRow_fields iprot record = do
  (_,_t206,_id207) <- readFieldBegin iprot
  if _t206 == T_STOP then return record else
    case _id207 of 
      1 -> if _t206 == T_STRING then do
        s <- readBinary iprot
        read_CqlRow_fields iprot record{f_CqlRow_key=Just s}
        else do
          skip iprot _t206
          read_CqlRow_fields iprot record
      2 -> if _t206 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Column iprot);r <- f (n-1); return $ v:r}} in do {(_etype211,_size208) <- readListBegin iprot; f _size208})
        read_CqlRow_fields iprot record{f_CqlRow_columns=Just s}
        else do
          skip iprot _t206
          read_CqlRow_fields iprot record
      _ -> do
        skip iprot _t206
        readFieldEnd iprot
        read_CqlRow_fields iprot record
read_CqlRow iprot = do
  _ <- readStructBegin iprot
  record <- read_CqlRow_fields iprot (CqlRow{f_CqlRow_key=Nothing,f_CqlRow_columns=Nothing})
  readStructEnd iprot
  return record
data CqlResult = CqlResult{f_CqlResult_type :: Maybe CqlResultType,f_CqlResult_rows :: Maybe [CqlRow],f_CqlResult_num :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_CqlResult oprot record = do
  writeStructBegin oprot "CqlResult"
  case f_CqlResult_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_CqlResult_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,2)
    (let {f [] = return (); f (_viter215:t) = do {write_CqlRow oprot _viter215;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_CqlResult_num record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("num",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CqlResult_fields iprot record = do
  (_,_t217,_id218) <- readFieldBegin iprot
  if _t217 == T_STOP then return record else
    case _id218 of 
      1 -> if _t217 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_CqlResult_fields iprot record{f_CqlResult_type=Just s}
        else do
          skip iprot _t217
          read_CqlResult_fields iprot record
      2 -> if _t217 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_CqlRow iprot);r <- f (n-1); return $ v:r}} in do {(_etype222,_size219) <- readListBegin iprot; f _size219})
        read_CqlResult_fields iprot record{f_CqlResult_rows=Just s}
        else do
          skip iprot _t217
          read_CqlResult_fields iprot record
      3 -> if _t217 == T_I32 then do
        s <- readI32 iprot
        read_CqlResult_fields iprot record{f_CqlResult_num=Just s}
        else do
          skip iprot _t217
          read_CqlResult_fields iprot record
      _ -> do
        skip iprot _t217
        readFieldEnd iprot
        read_CqlResult_fields iprot record
read_CqlResult iprot = do
  _ <- readStructBegin iprot
  record <- read_CqlResult_fields iprot (CqlResult{f_CqlResult_type=Nothing,f_CqlResult_rows=Nothing,f_CqlResult_num=Nothing})
  readStructEnd iprot
  return record
